an8218fr-s@power:~/simplex$ opreport -t 0.7 -l
Using /home/an8218fr-s/simplex/oprofile_data/samples/ for samples directory.
CPU: ppc64 POWER8, speed 3491 MHz (estimated)
Counted CYCLES events (Cycles) with a unit mask of 0x00 (No unit mask) count 100000
samples  %        symbol name
76001    91.5377  pivot
4122      4.9647  xsimplex
685       0.8250  initial
605       0.7287  extend


GPROF:
granularity: each sample hit covers 2 byte(s) for 0.26% of 3.91 seconds

  %   cumulative   self              self     total           
 time   seconds   seconds    calls  ms/call  ms/call  name    
 90.1       3.52     3.52   211731     0.02     0.02  pivot [7]
  5.6       3.74     0.22     6983     0.03     0.52  xsimplex <cycle 1> [6]
  1.3       3.79     0.05     6983     0.01     0.01  init [10]
  0.8       3.82     0.03     3498     0.01     0.01  extend [11]
  0.8       3.85     0.03     2624     0.01     0.01  push [12]
  0.5       3.87     0.02     6983     0.00     0.03  initial <cycle 1> [8]
  0.5       3.89     0.02     3484     0.01     0.02  prepare [9]
  0.3       3.90     0.01   212301     0.00     0.00  select_nonbasic [13]
  0.3       3.91     0.01     3499     0.00     0.00  free_node [14]
  0.0       3.91     0.00    51804     0.00     0.00  is_integer [16]
  0.0       3.91     0.00     3499     0.00     1.10  simplex [5]
  0.0       3.91     0.00     3498     0.00     1.12  succ [3]
  0.0       3.91     0.00     2731     0.00     0.00  integer [17]
  0.0       3.91     0.00     2729     0.00     0.00  branch [18]
  0.0       3.91     0.00     2625     0.00     0.00  create_element [19]
  0.0       3.91     0.00     1749     0.00     0.00  pop [20]
  0.0       3.91     0.00        2     0.00     1.25  bound [15]
  0.0       3.91     0.00        1     0.00     0.00  initial_node [21]
  0.0       3.91     0.00        1     0.00  3912.08  intopt [1]


Index by function name

  [15] bound                [21] initial_node         [12] push               
  [18] branch               [17] integer              [13] select_nonbasic    
  [19] create_element        [1] intopt                [5] simplex            
  [11] extend               [16] is_integer            [3] succ               
  [14] free_node             [7] pivot                 [6] xsimplex           
  [10] init                 [20] pop                   [4] <cycle 1>  


GCOV:
Gcov generates exact counts of the number of times each statement in a program is executed and annotates 
source code to add instrumentation.
With the command "gcov -b intopt.c" it states if something was executed or not
and how many % of times it reached this statement

For the print outs see further down.


Valgrind:
How many instructions in total - I refs: 2,560,056,968
How many load instructions in total - D refs (Dr): 10,955,517 
How many store instructions in total - D refs (Dw): 4,474,773
What are the cache miss rates? -  I1 miss rate: 0.01%
Are the cache likely to be a performance problem for this input? - No as the cache miss rate is very low.

an8218fr-s@power:~/simplex$ valgrind --tool=cachegrind --I1=65536,1,128 --D1=32768,2,128 \
> > --LL=1048576,8,128 ./a.out < i
==77376== Cachegrind, a cache and branch-prediction profiler
==77376== Copyright (C) 2002-2017, and GNU GPL'd, by Nicholas Nethercote et al.
==77376== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==77376== Command: ./a.out
==77376== 
--77376-- Warning: Cannot auto-detect cache config, using defaults.
--77376--          Run with -v to see.
==77376== 
==77376== I   refs:      2,560,056,968
==77376== I1  misses:          377,503
==77376== LLi misses:            1,422
==77376== I1  miss rate:          0.01%
==77376== LLi miss rate:          0.00%
==77376== 
==77376== D   refs:        883,579,800  (725,361,176 rd   + 158,218,624 wr)
==77376== D1  misses:        1,337,048  (  1,189,045 rd   +     148,003 wr)
==77376== LLd misses:          194,948  (    119,477 rd   +      75,471 wr)
==77376== D1  miss rate:           0.2% (        0.2%     +         0.1%  )
==77376== LLd miss rate:           0.0% (        0.0%     +         0.0%  )
==77376== 
==77376== LL refs:           1,714,551  (  1,566,548 rd   +     148,003 wr)
==77376== LL misses:           196,370  (    120,899 rd   +      75,471 wr)
==77376== LL miss rate:            0.0% (        0.0%     +         0.0%  )


GCOV OUTPUTS:
an8218fr-s@power:~/simplex$ gcov intopt.c
File 'intopt.c'
Lines executed:96.04% of 379
Creating 'intopt.c.gcov'

an8218fr-s@power:~/simplex$ cat intopt.c.gcov 
        -:    0:Source:intopt.c
        -:    0:Graph:intopt.gcno
        -:    0:Data:intopt.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <math.h>
        -:    4:#include <stdbool.h>
        -:    5:
        -:    6:#define EPSILON 1e-6
        -:    7:
        -:    8:struct simplex_t {
        -:    9:    double y; // y
        -:   10:    int m; // Constraints
        -:   11:    int n; // Decision variables
        -:   12:    int* var; // 0..n-1 are nonbasic
        -:   13:    double* b; // b
        -:   14:    double* x; // x
        -:   15:    double* c; // c
        -:   16:    double** a; // A
        -:   17:};
        -:   18:
        -:   19:struct node_t {
        -:   20:    int m; /* Constraints. */
        -:   21:    int n; /* Decision variables. */
        -:   22:    int k; /* Parent branches on x k . */
        -:   23:    int h; /* Branch on x h . */
        -:   24:    double xh; /* x h . */
        -:   25:    double ak; /* Parent a k . */
        -:   26:    double bk; /* Parent b k . */
        -:   27:    double* min; /* Lower bounds. */
        -:   28:    double* max; /* Upper bounds. */
        -:   29:    double** a; /* A . */
        -:   30:    double* b; /* b . */
        -:   31:    double* x; /* x . */
        -:   32:    double* c; /* c . */
        -:   33:    double z; /* z. */
        -:   34:};
        -:   35:
        -:   36:struct set_element {
        -:   37:    struct set_element *next;
        -:   38:    struct node_t *node;
        -:   39:};
        -:   40:
        -:   41:
        -:   42:struct set {
        -:   43:    struct set_element *head;
        -:   44:};
        -:   45:
     2625:   46:struct set_element *create_element(struct node_t *node) {
     2625:   47:    struct set_element *element = (struct set_element *)malloc(sizeof(struct set_element));
        -:   48:
     2625:   49:    element->next = NULL;
     2625:   50:    element->node = node;
        -:   51:
     2625:   52:    return element;
        -:   53:}
        -:   54:
     2624:   55:void push(struct set *set, struct node_t *node) {
     2624:   56:    struct set_element *element = set->head;
        -:   57:
     2624:   58:    if (element == NULL) {
        1:   59:        element = create_element(node);
        1:   60:        set->head = element;
        1:   61:        return;
        -:   62:    }
        -:   63:
        -:   64:    while (1) {
  2317123:   65:        if (element->node == node) {
    #####:   66:            return;
        -:   67:        }
        -:   68:
  1159873:   69:        if (element->next != NULL) {
  1157250:   70:            element = element->next;
        -:   71:        } else {
     2623:   72:            break;
        -:   73:        }
        -:   74:    }
        -:   75:
     2623:   76:    struct set_element *new_element = create_element(node);
     2623:   77:    element->next = new_element;
        -:   78:}
        -:   79:
     1749:   80:struct node_t *pop(struct set *set) {
     1749:   81:    struct node_t *node = set->head->node;
     1749:   82:    struct set_element *element = set->head;
     1749:   83:    set->head = set->head->next;
        -:   84:
     1749:   85:    free(element);
     1749:   86:    return node;
        -:   87:}
        -:   88:
        -:   89:double simplex(int m, int n, double** a, double* b, double* c, double* x, double y);
        -:   90:double xsimplex(int m, int n, double** a, double* b, double* c, double* x, double y, int* var, bool h);
        -:   91:void pivot(struct simplex_t* s, int row, int col);
        -:   92:int initial(struct simplex_t* s, int m, int n, double** a, double* b, double* c, double* x, double y, int* var);
        -:   93:int init(struct simplex_t* s, int m, int n, double** a, double* b, double* c, double* x, double y, int* var);
        -:   94:void prepare(struct simplex_t* s, int k);
        -:   95:int select_nonbasic(struct simplex_t* s);
        -:   96:struct node_t *initial_node(int m, int n, double** a, double* b, double* c);
        -:   97:struct node_t *extend(struct node_t *p, int m, int n, double **a, double *b, double *c, int k, double ak, double bk);
        -:   98:int is_integer(double* xp);
        -:   99:int integer(struct node_t* p);
        -:  100:void bound(struct node_t* p, struct set *h, double* zp, double* x);
        -:  101:int branch(struct node_t* q, double z);
        -:  102:double intopt(int m, int n, double **a, double *b, double *c, double *x);
        -:  103:void free_node(struct node_t* node);
        -:  104:
        1:  105:int main(int argc, char **args){
        -:  106:    int m, n;
        -:  107:    double *c, *b;
        -:  108:    double **a;
        1:  109:    scanf("%d %d", &m, &n);
        1:  110:    c = calloc(n, sizeof(double));
        1:  111:    b = calloc(m, sizeof(double));
        1:  112:    a = calloc(m, sizeof(double*));
       21:  113:    for (int i = 0; i < n; i++) {
       20:  114:        scanf("%lf", &c[i]);
        -:  115:    }
       21:  116:    for (int i = 0; i < m; i++) {
       20:  117:        a[i] = calloc(n + 1, sizeof(double));
      420:  118:        for (int x = 0; x < n; x++) {
      400:  119:            scanf("%lf", &a[i][x]);
        -:  120:        }
        -:  121:    }
       21:  122:    for (int i = 0; i < m; i++) {
       20:  123:        scanf("%lf", &b[i]);
        -:  124:    }
        1:  125:    printf("m = %d, n = %d\n", m, n);
        1:  126:    printf("max z = ");
       21:  127:    for (int i = 0; i < n; i++) {
       20:  128:        printf("%10.3lf", c[i]);
       20:  129:        if (i < n - 1) {
       19:  130:            printf(" + ");
        -:  131:        } else {
        1:  132:            printf("\n");
        -:  133:        }
        -:  134:    }
        1:  135:    double *xvalues = calloc(n + m + 1, sizeof(double));
       21:  136:    for (int y = 0; y < m; y++) {
       20:  137:        printf("        ");
       20:  138:        xvalues[y] = 0.0;
      420:  139:        for (int x = 0; x < n; x++) {
      400:  140:            xvalues[y] += a[y][x];
      400:  141:            printf("%10.3lf", a[y][x]);
      400:  142:            if (x < n - 1) {
      380:  143:                printf(" + ");
        -:  144:            } else {
       20:  145:                printf(" \u2264 %lf", b[y]);
        -:  146:            }
        -:  147:        }
       20:  148:        printf("\n");
        -:  149:    }
        1:  150:    printf("\n");
        -:  151:    //double result = simplex(m,n,a,b,c,xvalues,0.0);
        1:  152:    double result = intopt(m, n, a, b, c, xvalues);
        1:  153:    free(c);
        1:  154:    free(b);
       21:  155:    for (int i = 0; i < m; i++) {
       20:  156:        free(a[i]);
        -:  157:    }
        1:  158:    free(a);
        1:  159:    free(xvalues);
        1:  160:    printf("Result: %lf\n", result);
        1:  161:    return 0;
        -:  162:}
        -:  163:
        -:  164:/* START OF SIMPLEX */
        -:  165:
        -:  166:// void print_simplex(struct simplex_t* s) {
        -:  167://     printf("m = %d, n = %d\n", s->m, s->n);
        -:  168://     printf("max z = ");
        -:  169://     for (int i = 0; i < s->n; i++) {
        -:  170://         printf("%10.3lf", s->c[i]);
        -:  171://         if (i < s->n - 1) {
        -:  172://             printf(" + ");
        -:  173://         } else {
        -:  174://             printf("\n");
        -:  175://         }
        -:  176://     }
        -:  177:
        -:  178://     for (int y = 0; y < s->m; y++) {
        -:  179://         printf("        ");
        -:  180://         for (int x = 0; x < s->n; x++) {
        -:  181://             printf("%10.3lf", s->a[y][x]);
        -:  182://             if (x < s->n - 1) {
        -:  183://                 printf(" + ");
        -:  184://             } else {
        -:  185://                 printf(" \u2264 %lf", s->b[y]);
        -:  186://             }
        -:  187://         }
        -:  188://         printf("\n");
        -:  189://     }
        -:  190://     printf("\n");
        -:  191:// }
        -:  192:
     6983:  193:int init(struct simplex_t* s, int m, int n, double** a, double* b, double* c, double* x, double y, int* var){
        -:  194:    int i,k;
     6983:  195:    s->m = m;
     6983:  196:    s->n = n;
     6983:  197:    s->a = a;
     6983:  198:    s->b = b;
        -:  199:
     6983:  200:    s->c = c;
     6983:  201:    s->x = x;
     6983:  202:    s->y = y;
     6983:  203:    s->var = var;
     6983:  204:    if(s->var == NULL){
     3499:  205:        s->var = (int*)malloc((m+n+1)*sizeof(int));
   176457:  206:        for(i = 0; i < m+n; i++){
   172958:  207:            s->var[i] = i;
        -:  208:        }
        -:  209:    }
   205558:  210:    for(k = 0, i = 1; i < m; i++){
   198575:  211:        if(s->b[i] < s->b[k]){
    19497:  212:            k = i;
        -:  213:        }
        -:  214:    }
        -:  215:
     6983:  216:    return k;
        -:  217:}
        -:  218:
     3484:  219:void prepare(struct simplex_t* s, int k){
     3484:  220:    int m = s->m;
     3484:  221:    int n = s->n;
        -:  222:    int i;
        -:  223:    // make room for x_{m+n} at s.var[n] by moving s.var[n..n+m-1] one step to the right
   106064:  224:    for(i = m + n; i > n; i--){
   102580:  225:        s->var[i] = s->var[i-1];
        -:  226:    }
     3484:  227:    s->var[n] = m+n;
        -:  228:    // add x_{m+n} to each constraint
     3484:  229:    n++;
   106064:  230:    for(i = 0; i < m; i++){
   102580:  231:        s->a[i][n-1] = -1;
        -:  232:    }
     3484:  233:    s->x = (double*)calloc((m + n), sizeof(double));
     3484:  234:    s->c = (double*)calloc(n, sizeof(double));
     3484:  235:    s->c[n-1] = -1;
     3484:  236:    s->n = n;
     3484:  237:    pivot(s,k,n-1);
     3484:  238:}
        -:  239:
     6983:  240:int initial(struct simplex_t* s, int m, int n, double** a, double* b, double* c, double* x, double y, int* var){
        -:  241:    int i,j,k;
        -:  242:    double w;
        -:  243:    double* t; // This could cause issues, unknown variable
     6983:  244:    k = init(s,m,n,a,b,c,x,y,var);
     6983:  245:    if(b[k] >= 0){
     3499:  246:        return 1;
        -:  247:    }
     3484:  248:    prepare(s,k);
     3484:  249:    n = s->n;
     3484:  250:    s->y = xsimplex(m, n, s->a, s->b, s->c, s->x, 0.0, s->var, 1);
   142791:  251:    for(i = 0; i < m + n; i++){
   142791:  252:        if(s->var[i] == m + n - 1) {
     3484:  253:            if(fabs(s->x[i]) > EPSILON) {
      768:  254:                free(s->x);
      768:  255:                free(s->c);
      768:  256:                return 0;
        -:  257:            } else {
     2716:  258:                break;
        -:  259:            }
        -:  260:        }
        -:  261:    }
     2716:  262:    if(i >= n){
        -:  263:        // x_{n+m} is basic. find good nonbasic
    47542:  264:        for(j = k = 0; k < n; k++){
    45381:  265:            if(fabs(s->a[i-n][k]) > fabs(s->a[i-n][j])){
     5075:  266:                j = k;
        -:  267:            }
        -:  268:        }
     2161:  269:        pivot(s,i-n,j);
     2161:  270:        i = j;
        -:  271:    }
     2716:  272:    if(i < n-1){
        -:  273:        // x_{n+m} is nonbasic and not last. swap columns i and n-1
     2716:  274:        k = s->var[i];
     2716:  275:        s->var[i] = s->var[n-1];
     2716:  276:        s->var[n-1] = k;
    82163:  277:        for(k = 0; k < m; k++){
    79447:  278:            w = s->a[k][n-1];
    79447:  279:            s->a[k][n-1] = s->a[k][i];
    79447:  280:            s->a[k][i] = w;
        -:  281:        }
        -:  282:    }
        -:  283:
     2716:  284:    free(s->c);
     2716:  285:    s->c = c;
     2716:  286:    s->y = y;
    82163:  287:    for(k = n-1; k < n+m-1; k++){
    79447:  288:        s->var[k] = s->var[k+1];
        -:  289:    }
     2716:  290:    n = s->n = s->n-1;
     2716:  291:    t = (double*) calloc(n, sizeof(double));
    57036:  292:    for(k = 0; k < n; k++) {
   886448:  293:        for(j = 0; j < n; j++){
   859830:  294:            if(k == s->var[j]){
        -:  295:                // x_k is nonbasic. add c_k
    27702:  296:                t[j] = t[j] + s->c[k];
    27702:  297:                goto next_k;
        -:  298:            }
        -:  299:        }
        -:  300:
        -:  301:        // x_k is basic
   388218:  302:        for(j = 0; j < m; j++){
   388218:  303:            if(s->var[n+j] == k){
        -:  304:                // x_k is at row j
    26618:  305:                break;
        -:  306:            }
        -:  307:        }
    26618:  308:        s->y = s->y + s->c[k]*s->b[j];
   558978:  309:        for(i = 0; i < n; i++){
   532360:  310:            t[i] = t[i] - s->c[k]*s->a[j][i];
        -:  311:        }
    26618:  312:    next_k:
        -:  313:        ;
        -:  314:    }
    57036:  315:    for(i = 0; i < n; i++){
    54320:  316:        s->c[i] = t[i];
        -:  317:    }
     2716:  318:    free(t);
     2716:  319:    free(s->x);
     2716:  320:    return 1;
        -:  321:}
        -:  322:
     3499:  323:double simplex(int m, int n, double** a, double* b, double* c, double* x, double y) {
     3499:  324:    return xsimplex(m,n,a,b,c,x,y,NULL,false);
        -:  325:}
        -:  326:
     6983:  327:double xsimplex(int m, int n, double** a, double* b, double* c, double* x, double y, int* var, bool h){
        -:  328:    struct simplex_t s;
        -:  329:    int i, row, col;
        -:  330:
     6983:  331:    if(!initial(&s,m,n,a,b,c,x,y,var)){
      768:  332:        free(s.var);
      768:  333:        return NAN;
        -:  334:    }
        -:  335:    //print_simplex(&s);
   218516:  336:    while((col = select_nonbasic(&s)) >= 0){
   206086:  337:        row = -1;
  6294682:  338:        for(i = 0; i < m; i++){
  6088596:  339:            if(a[i][col] > EPSILON && (row < 0 || b[i] / a[i][col] < b[row] / a[row][col])) {
   684991:  340:                row = i;
        -:  341:            }
        -:  342:        }
   206086:  343:        if(row < 0){
    #####:  344:            free(s.var);
    #####:  345:            return INFINITY;
        -:  346:        }
   206086:  347:        pivot(&s,row,col);
        -:  348:        //print_simplex(&s);
        -:  349:    }
     6215:  350:    if(h == 0){
    57351:  351:        for(i = 0; i < n; i++){
    54620:  352:            if(s.var[i] < n){
    23182:  353:                x[s.var[i]] = 0;
        -:  354:            }
        -:  355:        }
    82576:  356:        for(i = 0; i < m; i++){
    79845:  357:            if (s.var[n + i] < n) {
    31438:  358:                x[s.var[n + i]] = s.b[i];
        -:  359:            }
        -:  360:        }
     2731:  361:        free(s.var);
        -:  362:    } else {
    76648:  363:        for(i = 0; i < n; i++){
    73164:  364:            x[i] = 0;
        -:  365:        }
   106064:  366:        for(i = n; i < n+m; i++){
   102580:  367:            x[i] = s.b[i-n];
        -:  368:        }
        -:  369:    }
     6215:  370:    double result = s.y;
     6215:  371:    return result;
        -:  372:}
        -:  373:
   212301:  374:int select_nonbasic(struct simplex_t* s){
  1768039:  375:    for(int i = 0; i < s->n; i++){
  1761824:  376:        if(s->c[i] > EPSILON){
   206086:  377:            return i;
        -:  378:        }
        -:  379:    }
     6215:  380:    return -1;
        -:  381:}
        -:  382:
   211731:  383:void pivot(struct simplex_t* s, int row, int col) {
        -:  384:    // printf("Row: %d, column: %d\n", row, col);
   211731:  385:    double** a = s->a;
   211731:  386:    double* b = s->b;
   211731:  387:    double* c = s->c;
   211731:  388:    int m = s->m;
   211731:  389:    int n = s->n;
        -:  390:    int i, j, t;
   211731:  391:    t = s->var[col];
   211731:  392:    s->var[col] = s->var[n+row];
   211731:  393:    s->var[n+row] = t;
   211731:  394:    s->y = s->y + c[col]*b[row] / a[row][col];
  4590861:  395:    for(i = 0; i < n; i++){
  4379130:  396:        if(i != col){
  4167399:  397:            c[i] -= (c[col] * (a[row][i] / a[row][col]));
        -:  398:        }
        -:  399:    }
   211731:  400:    c[col] = -c[col] / a[row][col];
  6466589:  401:    for(i = 0; i < m; i++){
  6254858:  402:        if(i != row){
  6043127:  403:            b[i] = b[i] - a[i][col] * b[row] / a[row][col];
        -:  404:        }
        -:  405:    }
  6466589:  406:    for(i = 0; i < m; i++){
  6254858:  407:        if(i != row){
131080061:  408:            for(j = 0; j < n; j++){
125036934:  409:                if(j != col){
118993807:  410:                    a[i][j] = a[i][j] - a[i][col] * a[row][j] / a[row][col];
        -:  411:                }
        -:  412:            }
        -:  413:        }
        -:  414:    }
  6466589:  415:    for(i = 0; i < m; i++){
  6254858:  416:        if(i != row){
  6043127:  417:            a[i][col] = -a[i][col] / a[row][col];
        -:  418:        }
        -:  419:    }
  4590861:  420:    for(i = 0; i < n; i++){
  4379130:  421:        if(i != col){
  4167399:  422:            a[row][i] = a[row][i] / a[row][col];
        -:  423:        }
        -:  424:    }
        -:  425:    /*for (int i = 0; i < n; i++) {
        -:  426:        printf("%lf ", c[i]);
        -:  427:    }*/
   211731:  428:    b[row] = b[row] / a[row][col];
   211731:  429:    a[row][col] = 1 / a[row][col];
   211731:  430:}
        -:  431:
        -:  432:/* END OF SIMPLEX */
        -:  433:
        -:  434:/* START OF BRANCH AND BOUND */
        -:  435:
        1:  436:struct node_t *initial_node(int m, int n, double** a, double* b, double* c) {
        1:  437:    struct node_t* p = (struct node_t*)malloc(sizeof(struct node_t));
        1:  438:    p->a = calloc(m + 1, sizeof(double*));
       22:  439:    for(int i = 0; i < m+1; i++){
       21:  440:        p->a[i] = calloc(n + 1, sizeof(double));
        -:  441:    }
        1:  442:    p->b = calloc(m + 1, sizeof(double));
        1:  443:    p->c = calloc(n + 1, sizeof(double));
        1:  444:    p->x = calloc(n + 1, sizeof(double));
        1:  445:    p->min = calloc(n, sizeof(double));
        1:  446:    p->max = calloc(n, sizeof(double));
        1:  447:    p->m = m;
        1:  448:    p->n = n;
        -:  449:
       21:  450:    for(int i = 0; i < m; i++){
      440:  451:        for(int j = 0; j < n+1; j++){
      420:  452:            p->a[i][j] = a[i][j];
        -:  453:        }
        -:  454:    }
        -:  455:
       21:  456:    for(int i = 0; i < m; i++){
       20:  457:        p->b[i] = b[i];
        -:  458:    }
        -:  459:
       21:  460:    for(int i = 0; i < n; i++){
       20:  461:        p->c[i] = c[i];
        -:  462:    }
        -:  463:
       21:  464:    for(int i = 0; i < n; i++){
       20:  465:        p->min[i] = -INFINITY;
       20:  466:        p->max[i] = INFINITY;
        -:  467:    }
        -:  468:
        1:  469:    return p;
        -:  470:}
        -:  471:
     3498:  472:struct node_t *extend(struct node_t *p, int m, int n, double **a, double *b, double *c, int k, double ak, double bk) {
     3498:  473:    struct node_t *q = (struct node_t *)malloc(sizeof(struct node_t));
     3498:  474:    q->k = k;
     3498:  475:    q->ak = ak;
     3498:  476:    q->bk = bk;
        -:  477:
     3498:  478:    if (ak > 0 && p->max[k] < INFINITY) {
      590:  479:        q->m = p->m;
     2908:  480:    } else if (ak < 0 && p->min[k] > 0) {
      316:  481:        q->m = p->m;
        -:  482:    } else {
     2592:  483:        q->m = p->m + 1;
        -:  484:    }
        -:  485:
     3498:  486:    q->n = p->n;
     3498:  487:    q->h = -1;
     3498:  488:    q->a = (double **)calloc(q->m + 1, sizeof(double*)); // note normally q.m > m
        -:  489:
   109954:  490:    for(int i = 0; i < q->m + 1; i++) {
   106456:  491:        q->a[i] = (double *)calloc(q->n + 1, sizeof(double));
        -:  492:    }
        -:  493:
     3498:  494:    q->b = (double *)calloc(q->m + 1, sizeof(double));
     3498:  495:    q->c = (double *)calloc(q->n + 1, sizeof(double));
     3498:  496:    q->x = (double *)calloc(q->n + 1, sizeof(double));
     3498:  497:    q->min = (double *)calloc(n, sizeof(double));
     3498:  498:    q->max = (double *)calloc(n, sizeof(double));
        -:  499:
    73458:  500:    for (int i = 0; i < n; i++) {
    69960:  501:        q->min[i] = p->min[i];
    69960:  502:        q->max[i] = p->max[i];
        -:  503:    }
        -:  504:
    73458:  505:    for (int i = 0; i < m; i++) {
  1469160:  506:        for (int j = 0; j < n; j++) {
  1399200:  507:            q->a[i][j] = a[i][j];
        -:  508:        }
        -:  509:    }
        -:  510:
    73458:  511:    for (int i = 0; i < m; i++) {
    69960:  512:        q->b[i] = b[i];
        -:  513:    }
        -:  514:
    73458:  515:    for (int i = 0; i < n; i++) {
    69960:  516:        q->c[i] = c[i];
        -:  517:    }
        -:  518:
     3498:  519:    if (ak > 0) {
     1749:  520:        if ((isinf(q->max[k]) && q->max[k] > 0) || (bk < q->max[k])) {
     1749:  521:            q->max[k] = bk;
        -:  522:        }
     1749:  523:    } else if ((isinf(q->min[k]) && q->min[k] < 0) || (-bk > q->min[k])) {
     1749:  524:        q->min[k] = -bk;
        -:  525:    }
        -:  526:
    73458:  527:    for (int i = m, j = 0; j < n; j++) {
    69960:  528:        if (!isinf(q->min[j]) || q->min[j] > 0.0) {
    13195:  529:            q->a[i][j] = -1;
    13195:  530:            q->b[i] = -q->min[j];
    13195:  531:            i++;
        -:  532:        }
    69960:  533:        if (!isinf(q->max[j]) || q->max[j] < 0.0) {
    19803:  534:            q->a[i][j] = 1;
    19803:  535:            q->b[i] = q->max[j];
    19803:  536:            i++;
        -:  537:        }
        -:  538:    }
        -:  539:
     3498:  540:    return q;
        -:  541:}
        -:  542:
    51804:  543:int is_integer(double* xp){
    51804:  544:    double x = *xp;
    51804:  545:    double r = round(x);
    51804:  546:    if (fabs(r-x) < EPSILON) {
    46450:  547:        *xp = r;
    46450:  548:        return 1;
        -:  549:    } else {
     5354:  550:        return 0;
        -:  551:    }
        -:  552:}
        -:  553:
     2731:  554:int integer(struct node_t* p){
    26412:  555:    for (int i = 0; i < p->n; i++) {
    26410:  556:        if (!is_integer(&p->x[i])) {
     2729:  557:            return 0;
        -:  558:        }
        -:  559:    }
        2:  560:    return 1;
        -:  561:}
        -:  562:
        2:  563:void bound(struct node_t* p, struct set *h, double* zp, double* x) {
        2:  564:    if (p->z > *zp) {
        2:  565:        *zp = p->z;
        -:  566:
       42:  567:        for(int i = 0; i < p->n; i++){
       40:  568:            x[i] = p->x[i];
        -:  569:        }
        -:  570:
        2:  571:        if (h->head == NULL) {
    #####:  572:            return;
        -:  573:        }
        -:  574:
        -:  575:        // remove and delete all nodes q in h with q.z < p.z
      851:  576:        while (h->head != NULL && h->head->node->z < p->z) {
      847:  577:            struct set_element *head = h->head;
      847:  578:            h->head = h->head->next;
      847:  579:            free_node(head->node);
      847:  580:            free(head);
        -:  581:        }
        -:  582:
        2:  583:        struct set_element *element_prev = h->head;
        -:  584:        struct set_element *element;
        -:  585:
        2:  586:        if (h->head == NULL) {
        1:  587:            return;
        -:  588:        } else {
        1:  589:            element = h->head->next;
        -:  590:        }
        -:  591:
      459:  592:        while (element != NULL) {
      457:  593:            struct node_t *q = element->node;
      457:  594:            if (q->z < p->z) {
       29:  595:                element_prev->next = element->next;
       29:  596:                free_node(q);
       29:  597:                free(element);
       29:  598:                element = element_prev->next;
        -:  599:            } else {
      428:  600:                element_prev = element;
      428:  601:                element = element->next;
        -:  602:            }
        -:  603:        }
        -:  604:    }
        -:  605:}
        -:  606:
     2729:  607:int branch(struct node_t* q, double z) {
        -:  608:    double min, max;
        -:  609:
     2729:  610:    if (q->z < z) {
      104:  611:        return 0;
        -:  612:    }
        -:  613:
    25394:  614:    for (int h = 0; h < q->n; h++) {
    25394:  615:        if (!is_integer(&q->x[h])) {
     2625:  616:            if (isinf(q->min[h]) && q->min[h] < 0.0) {
     2138:  617:                min = 0.0;
        -:  618:            } else {
      487:  619:                min = q->min[h];
        -:  620:            }
     2625:  621:            max = q->max[h];
        -:  622:
     2625:  623:            if (floor(q->x[h]) < min || ceil(q->x[h]) > max) {
    #####:  624:                continue;
        -:  625:            }
        -:  626:
     2625:  627:            q->h = h;
     2625:  628:            q->xh = q->x[h];
        -:  629:
        -:  630:            /* This causes an error if memory is free
        -:  631:               q is used later in code
        -:  632:            for(int i = 0; i < q->m + 1; i++) {
        -:  633:                free(q->a[i]);
        -:  634:            }
        -:  635:            free(q->a);
        -:  636:            free(q->b);
        -:  637:            free(q->c);
        -:  638:            free(q->x);
        -:  639:            */
        -:  640:
     2625:  641:            return 1;
        -:  642:        }
        -:  643:    }
        -:  644:
    #####:  645:    return 0;
        -:  646:}
        -:  647:
     3498:  648:void succ(struct node_t *p, struct set *h, int m, int n, double** a, double* b, double* c, int k, double ak, double bk, double* zp, double* x){
     3498:  649:    struct node_t* q = extend(p,m,n,a,b,c,k,ak,bk);
     3498:  650:    if (q == NULL) {
    #####:  651:        return;
        -:  652:    }
        -:  653:
     3498:  654:    q->z = simplex(q->m, q->n, q->a, q->b, q->c, q->x, 0);
     3498:  655:    if (isfinite(q->z)) {
     2730:  656:        if (integer(q)) {
        2:  657:            bound(q,h,zp,x);
     2728:  658:        } else if (branch(q, *zp)) {
     2624:  659:            push(h, q);
     2624:  660:            return;
        -:  661:        }
        -:  662:    }
      874:  663:    free_node(q);
        -:  664:}
        -:  665:
        1:  666:double intopt(int m, int n, double **a, double *b, double *c, double *x) {
        1:  667:    struct node_t *p = initial_node(m, n, a, b, c);
        -:  668:    struct set h;
        1:  669:    h.head = create_element(p);
        1:  670:    double z = -INFINITY;
        1:  671:    p->z = simplex(p->m, p->n, p->a, p->b, p->c, p->x, 0);
        1:  672:    if(integer(p) || !isfinite(p->z)){
    #####:  673:        z = p->z;
    #####:  674:        if (integer(p)) {
    #####:  675:            for(int i = 0; i < n; i++){
    #####:  676:                x[i] = p->x[i];
        -:  677:            }
        -:  678:        }
    #####:  679:        free_node(p);
    #####:  680:        free(h.head);
    #####:  681:        return z;
        -:  682:    }
        1:  683:    branch(p,z);
     1751:  684:    while(h.head != NULL) {
     1749:  685:        struct node_t *p = pop(&h);
     1749:  686:        succ(p, &h, m, n, a, b, c, p->h, 1, floor(p->xh), &z, x);
     1749:  687:        succ(p, &h, m, n, a, b, c, p->h, -1, -ceil(p->xh), &z, x);
     1749:  688:        free_node(p);
        -:  689:    }
        -:  690:
        1:  691:    if (z == -INFINITY) {
    #####:  692:        return NAN;
        -:  693:    } else {
        1:  694:        return z;
        -:  695:    }
        -:  696:}
        -:  697:
     3499:  698:void free_node(struct node_t* node){
     3499:  699:    free(node->min);
     3499:  700:    free(node->max);
     3499:  701:    free(node->b);
     3499:  702:    free(node->x);
     3499:  703:    free(node->c);
        -:  704:
   109976:  705:    for(int i = 0; i < node->m + 1; i++){
   106477:  706:        free(node->a[i]);
        -:  707:    }
        -:  708:
     3499:  709:    free(node->a);
     3499:  710:    free(node);
     3499:  711:}

an8218fr-s@power:~/simplex$ gcov -b intopt.c
File 'intopt.c'
Lines executed:96.04% of 379
Branches executed:98.35% of 242
Taken at least once:89.67% of 242
Calls executed:96.00% of 50
Creating 'intopt.c.gcov'

an8218fr-s@power:~/simplex$ cat intopt.c.gcov 
        -:    0:Source:intopt.c
        -:    0:Graph:intopt.gcno
        -:    0:Data:intopt.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <math.h>
        -:    4:#include <stdbool.h>
        -:    5:
        -:    6:#define EPSILON 1e-6
        -:    7:
        -:    8:struct simplex_t {
        -:    9:    double y; // y
        -:   10:    int m; // Constraints
        -:   11:    int n; // Decision variables
        -:   12:    int* var; // 0..n-1 are nonbasic
        -:   13:    double* b; // b
        -:   14:    double* x; // x
        -:   15:    double* c; // c
        -:   16:    double** a; // A
        -:   17:};
        -:   18:
        -:   19:struct node_t {
        -:   20:    int m; /* Constraints. */
        -:   21:    int n; /* Decision variables. */
        -:   22:    int k; /* Parent branches on x k . */
        -:   23:    int h; /* Branch on x h . */
        -:   24:    double xh; /* x h . */
        -:   25:    double ak; /* Parent a k . */
        -:   26:    double bk; /* Parent b k . */
        -:   27:    double* min; /* Lower bounds. */
        -:   28:    double* max; /* Upper bounds. */
        -:   29:    double** a; /* A . */
        -:   30:    double* b; /* b . */
        -:   31:    double* x; /* x . */
        -:   32:    double* c; /* c . */
        -:   33:    double z; /* z. */
        -:   34:};
        -:   35:
        -:   36:struct set_element {
        -:   37:    struct set_element *next;
        -:   38:    struct node_t *node;
        -:   39:};
        -:   40:
        -:   41:
        -:   42:struct set {
        -:   43:    struct set_element *head;
        -:   44:};
        -:   45:
function create_element called 2625 returned 100% blocks executed 100%
     2625:   46:struct set_element *create_element(struct node_t *node) {
     2625:   47:    struct set_element *element = (struct set_element *)malloc(sizeof(struct set_element));
        -:   48:
     2625:   49:    element->next = NULL;
     2625:   50:    element->node = node;
        -:   51:
     2625:   52:    return element;
        -:   53:}
        -:   54:
function push called 2624 returned 100% blocks executed 92%
     2624:   55:void push(struct set *set, struct node_t *node) {
     2624:   56:    struct set_element *element = set->head;
        -:   57:
     2624:   58:    if (element == NULL) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        1:   59:        element = create_element(node);
call    0 returned 100%
        1:   60:        set->head = element;
        1:   61:        return;
        -:   62:    }
        -:   63:
        -:   64:    while (1) {
  2317123:   65:        if (element->node == node) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   66:            return;
        -:   67:        }
        -:   68:
  1159873:   69:        if (element->next != NULL) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
  1157250:   70:            element = element->next;
        -:   71:        } else {
     2623:   72:            break;
        -:   73:        }
        -:   74:    }
        -:   75:
     2623:   76:    struct set_element *new_element = create_element(node);
call    0 returned 100%
     2623:   77:    element->next = new_element;
        -:   78:}
        -:   79:
function pop called 1749 returned 100% blocks executed 100%
     1749:   80:struct node_t *pop(struct set *set) {
     1749:   81:    struct node_t *node = set->head->node;
     1749:   82:    struct set_element *element = set->head;
     1749:   83:    set->head = set->head->next;
        -:   84:
     1749:   85:    free(element);
     1749:   86:    return node;
        -:   87:}
        -:   88:
        -:   89:double simplex(int m, int n, double** a, double* b, double* c, double* x, double y);
        -:   90:double xsimplex(int m, int n, double** a, double* b, double* c, double* x, double y, int* var, bool h);
        -:   91:void pivot(struct simplex_t* s, int row, int col);
        -:   92:int initial(struct simplex_t* s, int m, int n, double** a, double* b, double* c, double* x, double y, int* var);
        -:   93:int init(struct simplex_t* s, int m, int n, double** a, double* b, double* c, double* x, double y, int* var);
        -:   94:void prepare(struct simplex_t* s, int k);
        -:   95:int select_nonbasic(struct simplex_t* s);
        -:   96:struct node_t *initial_node(int m, int n, double** a, double* b, double* c);
        -:   97:struct node_t *extend(struct node_t *p, int m, int n, double **a, double *b, double *c, int k, double ak, double bk);
        -:   98:int is_integer(double* xp);
        -:   99:int integer(struct node_t* p);
        -:  100:void bound(struct node_t* p, struct set *h, double* zp, double* x);
        -:  101:int branch(struct node_t* q, double z);
        -:  102:double intopt(int m, int n, double **a, double *b, double *c, double *x);
        -:  103:void free_node(struct node_t* node);
        -:  104:
function main called 1 returned 100% blocks executed 100%
        1:  105:int main(int argc, char **args){
        -:  106:    int m, n;
        -:  107:    double *c, *b;
        -:  108:    double **a;
        1:  109:    scanf("%d %d", &m, &n);
call    0 returned 100%
        1:  110:    c = calloc(n, sizeof(double));
        1:  111:    b = calloc(m, sizeof(double));
        1:  112:    a = calloc(m, sizeof(double*));
       21:  113:    for (int i = 0; i < n; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  114:        scanf("%lf", &c[i]);
call    0 returned 100%
        -:  115:    }
       21:  116:    for (int i = 0; i < m; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  117:        a[i] = calloc(n + 1, sizeof(double));
      420:  118:        for (int x = 0; x < n; x++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
      400:  119:            scanf("%lf", &a[i][x]);
call    0 returned 100%
        -:  120:        }
        -:  121:    }
       21:  122:    for (int i = 0; i < m; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  123:        scanf("%lf", &b[i]);
call    0 returned 100%
        -:  124:    }
        1:  125:    printf("m = %d, n = %d\n", m, n);
call    0 returned 100%
        1:  126:    printf("max z = ");
call    0 returned 100%
       21:  127:    for (int i = 0; i < n; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  128:        printf("%10.3lf", c[i]);
call    0 returned 100%
       20:  129:        if (i < n - 1) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
       19:  130:            printf(" + ");
call    0 returned 100%
        -:  131:        } else {
        1:  132:            printf("\n");
call    0 returned 100%
        -:  133:        }
        -:  134:    }
        1:  135:    double *xvalues = calloc(n + m + 1, sizeof(double));
       21:  136:    for (int y = 0; y < m; y++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  137:        printf("        ");
call    0 returned 100%
       20:  138:        xvalues[y] = 0.0;
      420:  139:        for (int x = 0; x < n; x++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
      400:  140:            xvalues[y] += a[y][x];
      400:  141:            printf("%10.3lf", a[y][x]);
call    0 returned 100%
      400:  142:            if (x < n - 1) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
      380:  143:                printf(" + ");
call    0 returned 100%
        -:  144:            } else {
       20:  145:                printf(" \u2264 %lf", b[y]);
call    0 returned 100%
        -:  146:            }
        -:  147:        }
       20:  148:        printf("\n");
call    0 returned 100%
        -:  149:    }
        1:  150:    printf("\n");
call    0 returned 100%
        -:  151:    //double result = simplex(m,n,a,b,c,xvalues,0.0);
        1:  152:    double result = intopt(m, n, a, b, c, xvalues);
call    0 returned 100%
        1:  153:    free(c);
        1:  154:    free(b);
       21:  155:    for (int i = 0; i < m; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  156:        free(a[i]);
        -:  157:    }
        1:  158:    free(a);
        1:  159:    free(xvalues);
        1:  160:    printf("Result: %lf\n", result);
call    0 returned 100%
        1:  161:    return 0;
        -:  162:}
        -:  163:
        -:  164:/* START OF SIMPLEX */
        -:  165:
        -:  166:// void print_simplex(struct simplex_t* s) {
        -:  167://     printf("m = %d, n = %d\n", s->m, s->n);
        -:  168://     printf("max z = ");
        -:  169://     for (int i = 0; i < s->n; i++) {
        -:  170://         printf("%10.3lf", s->c[i]);
        -:  171://         if (i < s->n - 1) {
        -:  172://             printf(" + ");
        -:  173://         } else {
        -:  174://             printf("\n");
        -:  175://         }
        -:  176://     }
        -:  177:
        -:  178://     for (int y = 0; y < s->m; y++) {
        -:  179://         printf("        ");
        -:  180://         for (int x = 0; x < s->n; x++) {
        -:  181://             printf("%10.3lf", s->a[y][x]);
        -:  182://             if (x < s->n - 1) {
        -:  183://                 printf(" + ");
        -:  184://             } else {
        -:  185://                 printf(" \u2264 %lf", s->b[y]);
        -:  186://             }
        -:  187://         }
        -:  188://         printf("\n");
        -:  189://     }
        -:  190://     printf("\n");
        -:  191:// }
        -:  192:
function init called 6983 returned 100% blocks executed 100%
     6983:  193:int init(struct simplex_t* s, int m, int n, double** a, double* b, double* c, double* x, double y, int* var){
        -:  194:    int i,k;
     6983:  195:    s->m = m;
     6983:  196:    s->n = n;
     6983:  197:    s->a = a;
     6983:  198:    s->b = b;
        -:  199:
     6983:  200:    s->c = c;
     6983:  201:    s->x = x;
     6983:  202:    s->y = y;
     6983:  203:    s->var = var;
     6983:  204:    if(s->var == NULL){
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     3499:  205:        s->var = (int*)malloc((m+n+1)*sizeof(int));
   176457:  206:        for(i = 0; i < m+n; i++){
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
   172958:  207:            s->var[i] = i;
        -:  208:        }
        -:  209:    }
   205558:  210:    for(k = 0, i = 1; i < m; i++){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   198575:  211:        if(s->b[i] < s->b[k]){
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
    19497:  212:            k = i;
        -:  213:        }
        -:  214:    }
        -:  215:
     6983:  216:    return k;
        -:  217:}
        -:  218:
function prepare called 3484 returned 100% blocks executed 100%
     3484:  219:void prepare(struct simplex_t* s, int k){
     3484:  220:    int m = s->m;
     3484:  221:    int n = s->n;
        -:  222:    int i;
        -:  223:    // make room for x_{m+n} at s.var[n] by moving s.var[n..n+m-1] one step to the right
   106064:  224:    for(i = m + n; i > n; i--){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   102580:  225:        s->var[i] = s->var[i-1];
        -:  226:    }
     3484:  227:    s->var[n] = m+n;
        -:  228:    // add x_{m+n} to each constraint
     3484:  229:    n++;
   106064:  230:    for(i = 0; i < m; i++){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   102580:  231:        s->a[i][n-1] = -1;
        -:  232:    }
     3484:  233:    s->x = (double*)calloc((m + n), sizeof(double));
     3484:  234:    s->c = (double*)calloc(n, sizeof(double));
     3484:  235:    s->c[n-1] = -1;
     3484:  236:    s->n = n;
     3484:  237:    pivot(s,k,n-1);
call    0 returned 100%
     3484:  238:}
        -:  239:
function initial called 6983 returned 100% blocks executed 100%
     6983:  240:int initial(struct simplex_t* s, int m, int n, double** a, double* b, double* c, double* x, double y, int* var){
        -:  241:    int i,j,k;
        -:  242:    double w;
        -:  243:    double* t; // This could cause issues, unknown variable
     6983:  244:    k = init(s,m,n,a,b,c,x,y,var);
call    0 returned 100%
     6983:  245:    if(b[k] >= 0){
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     3499:  246:        return 1;
        -:  247:    }
     3484:  248:    prepare(s,k);
call    0 returned 100%
     3484:  249:    n = s->n;
     3484:  250:    s->y = xsimplex(m, n, s->a, s->b, s->c, s->x, 0.0, s->var, 1);
call    0 returned 100%
   142791:  251:    for(i = 0; i < m + n; i++){
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
   142791:  252:        if(s->var[i] == m + n - 1) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
     3484:  253:            if(fabs(s->x[i]) > EPSILON) {
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
      768:  254:                free(s->x);
      768:  255:                free(s->c);
      768:  256:                return 0;
        -:  257:            } else {
     2716:  258:                break;
        -:  259:            }
        -:  260:        }
        -:  261:    }
     2716:  262:    if(i >= n){
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -:  263:        // x_{n+m} is basic. find good nonbasic
    47542:  264:        for(j = k = 0; k < n; k++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    45381:  265:            if(fabs(s->a[i-n][k]) > fabs(s->a[i-n][j])){
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
     5075:  266:                j = k;
        -:  267:            }
        -:  268:        }
     2161:  269:        pivot(s,i-n,j);
call    0 returned 100%
     2161:  270:        i = j;
        -:  271:    }
     2716:  272:    if(i < n-1){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  273:        // x_{n+m} is nonbasic and not last. swap columns i and n-1
     2716:  274:        k = s->var[i];
     2716:  275:        s->var[i] = s->var[n-1];
     2716:  276:        s->var[n-1] = k;
    82163:  277:        for(k = 0; k < m; k++){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
    79447:  278:            w = s->a[k][n-1];
    79447:  279:            s->a[k][n-1] = s->a[k][i];
    79447:  280:            s->a[k][i] = w;
        -:  281:        }
        -:  282:    }
        -:  283:
     2716:  284:    free(s->c);
     2716:  285:    s->c = c;
     2716:  286:    s->y = y;
    82163:  287:    for(k = n-1; k < n+m-1; k++){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
    79447:  288:        s->var[k] = s->var[k+1];
        -:  289:    }
     2716:  290:    n = s->n = s->n-1;
     2716:  291:    t = (double*) calloc(n, sizeof(double));
    57036:  292:    for(k = 0; k < n; k++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
   886448:  293:        for(j = 0; j < n; j++){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   859830:  294:            if(k == s->var[j]){
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -:  295:                // x_k is nonbasic. add c_k
    27702:  296:                t[j] = t[j] + s->c[k];
    27702:  297:                goto next_k;
        -:  298:            }
        -:  299:        }
        -:  300:
        -:  301:        // x_k is basic
   388218:  302:        for(j = 0; j < m; j++){
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
   388218:  303:            if(s->var[n+j] == k){
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        -:  304:                // x_k is at row j
    26618:  305:                break;
        -:  306:            }
        -:  307:        }
    26618:  308:        s->y = s->y + s->c[k]*s->b[j];
   558978:  309:        for(i = 0; i < n; i++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
   532360:  310:            t[i] = t[i] - s->c[k]*s->a[j][i];
        -:  311:        }
    26618:  312:    next_k:
        -:  313:        ;
        -:  314:    }
    57036:  315:    for(i = 0; i < n; i++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    54320:  316:        s->c[i] = t[i];
        -:  317:    }
     2716:  318:    free(t);
     2716:  319:    free(s->x);
     2716:  320:    return 1;
        -:  321:}
        -:  322:
function simplex called 3499 returned 100% blocks executed 100%
     3499:  323:double simplex(int m, int n, double** a, double* b, double* c, double* x, double y) {
     3499:  324:    return xsimplex(m,n,a,b,c,x,y,NULL,false);
call    0 returned 100%
        -:  325:}
        -:  326:
function xsimplex called 6983 returned 100% blocks executed 97%
     6983:  327:double xsimplex(int m, int n, double** a, double* b, double* c, double* x, double y, int* var, bool h){
        -:  328:    struct simplex_t s;
        -:  329:    int i, row, col;
        -:  330:
     6983:  331:    if(!initial(&s,m,n,a,b,c,x,y,var)){
call    0 returned 100%
branch  1 taken 11% (fallthrough)
branch  2 taken 89%
      768:  332:        free(s.var);
      768:  333:        return NAN;
        -:  334:    }
        -:  335:    //print_simplex(&s);
   218516:  336:    while((col = select_nonbasic(&s)) >= 0){
call    0 returned 100%
branch  1 taken 97%
branch  2 taken 3% (fallthrough)
   206086:  337:        row = -1;
  6294682:  338:        for(i = 0; i < m; i++){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
  6088596:  339:            if(a[i][col] > EPSILON && (row < 0 || b[i] / a[i][col] < b[row] / a[row][col])) {
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
branch  2 taken 93% (fallthrough)
branch  3 taken 7%
branch  4 taken 16% (fallthrough)
branch  5 taken 84%
   684991:  340:                row = i;
        -:  341:            }
        -:  342:        }
   206086:  343:        if(row < 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  344:            free(s.var);
    #####:  345:            return INFINITY;
        -:  346:        }
   206086:  347:        pivot(&s,row,col);
call    0 returned 100%
        -:  348:        //print_simplex(&s);
        -:  349:    }
     6215:  350:    if(h == 0){
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
    57351:  351:        for(i = 0; i < n; i++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    54620:  352:            if(s.var[i] < n){
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
    23182:  353:                x[s.var[i]] = 0;
        -:  354:            }
        -:  355:        }
    82576:  356:        for(i = 0; i < m; i++){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
    79845:  357:            if (s.var[n + i] < n) {
branch  0 taken 39% (fallthrough)
branch  1 taken 61%
    31438:  358:                x[s.var[n + i]] = s.b[i];
        -:  359:            }
        -:  360:        }
     2731:  361:        free(s.var);
        -:  362:    } else {
    76648:  363:        for(i = 0; i < n; i++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    73164:  364:            x[i] = 0;
        -:  365:        }
   106064:  366:        for(i = n; i < n+m; i++){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   102580:  367:            x[i] = s.b[i-n];
        -:  368:        }
        -:  369:    }
     6215:  370:    double result = s.y;
     6215:  371:    return result;
        -:  372:}
        -:  373:
function select_nonbasic called 212301 returned 100% blocks executed 100%
   212301:  374:int select_nonbasic(struct simplex_t* s){
  1768039:  375:    for(int i = 0; i < s->n; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
  1761824:  376:        if(s->c[i] > EPSILON){
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
   206086:  377:            return i;
        -:  378:        }
        -:  379:    }
     6215:  380:    return -1;
        -:  381:}
        -:  382:
function pivot called 211731 returned 100% blocks executed 100%
   211731:  383:void pivot(struct simplex_t* s, int row, int col) {
        -:  384:    // printf("Row: %d, column: %d\n", row, col);
   211731:  385:    double** a = s->a;
   211731:  386:    double* b = s->b;
   211731:  387:    double* c = s->c;
   211731:  388:    int m = s->m;
   211731:  389:    int n = s->n;
        -:  390:    int i, j, t;
   211731:  391:    t = s->var[col];
   211731:  392:    s->var[col] = s->var[n+row];
   211731:  393:    s->var[n+row] = t;
   211731:  394:    s->y = s->y + c[col]*b[row] / a[row][col];
  4590861:  395:    for(i = 0; i < n; i++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
  4379130:  396:        if(i != col){
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
  4167399:  397:            c[i] -= (c[col] * (a[row][i] / a[row][col]));
        -:  398:        }
        -:  399:    }
   211731:  400:    c[col] = -c[col] / a[row][col];
  6466589:  401:    for(i = 0; i < m; i++){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
  6254858:  402:        if(i != row){
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
  6043127:  403:            b[i] = b[i] - a[i][col] * b[row] / a[row][col];
        -:  404:        }
        -:  405:    }
  6466589:  406:    for(i = 0; i < m; i++){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
  6254858:  407:        if(i != row){
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
131080061:  408:            for(j = 0; j < n; j++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
125036934:  409:                if(j != col){
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
118993807:  410:                    a[i][j] = a[i][j] - a[i][col] * a[row][j] / a[row][col];
        -:  411:                }
        -:  412:            }
        -:  413:        }
        -:  414:    }
  6466589:  415:    for(i = 0; i < m; i++){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
  6254858:  416:        if(i != row){
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
  6043127:  417:            a[i][col] = -a[i][col] / a[row][col];
        -:  418:        }
        -:  419:    }
  4590861:  420:    for(i = 0; i < n; i++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
  4379130:  421:        if(i != col){
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
  4167399:  422:            a[row][i] = a[row][i] / a[row][col];
        -:  423:        }
        -:  424:    }
        -:  425:    /*for (int i = 0; i < n; i++) {
        -:  426:        printf("%lf ", c[i]);
        -:  427:    }*/
   211731:  428:    b[row] = b[row] / a[row][col];
   211731:  429:    a[row][col] = 1 / a[row][col];
   211731:  430:}
        -:  431:
        -:  432:/* END OF SIMPLEX */
        -:  433:
        -:  434:/* START OF BRANCH AND BOUND */
        -:  435:
function initial_node called 1 returned 100% blocks executed 100%
        1:  436:struct node_t *initial_node(int m, int n, double** a, double* b, double* c) {
        1:  437:    struct node_t* p = (struct node_t*)malloc(sizeof(struct node_t));
        1:  438:    p->a = calloc(m + 1, sizeof(double*));
       22:  439:    for(int i = 0; i < m+1; i++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       21:  440:        p->a[i] = calloc(n + 1, sizeof(double));
        -:  441:    }
        1:  442:    p->b = calloc(m + 1, sizeof(double));
        1:  443:    p->c = calloc(n + 1, sizeof(double));
        1:  444:    p->x = calloc(n + 1, sizeof(double));
        1:  445:    p->min = calloc(n, sizeof(double));
        1:  446:    p->max = calloc(n, sizeof(double));
        1:  447:    p->m = m;
        1:  448:    p->n = n;
        -:  449:
       21:  450:    for(int i = 0; i < m; i++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
      440:  451:        for(int j = 0; j < n+1; j++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
      420:  452:            p->a[i][j] = a[i][j];
        -:  453:        }
        -:  454:    }
        -:  455:
       21:  456:    for(int i = 0; i < m; i++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  457:        p->b[i] = b[i];
        -:  458:    }
        -:  459:
       21:  460:    for(int i = 0; i < n; i++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  461:        p->c[i] = c[i];
        -:  462:    }
        -:  463:
       21:  464:    for(int i = 0; i < n; i++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       20:  465:        p->min[i] = -INFINITY;
       20:  466:        p->max[i] = INFINITY;
        -:  467:    }
        -:  468:
        1:  469:    return p;
        -:  470:}
        -:  471:
function extend called 3498 returned 100% blocks executed 100%
     3498:  472:struct node_t *extend(struct node_t *p, int m, int n, double **a, double *b, double *c, int k, double ak, double bk) {
     3498:  473:    struct node_t *q = (struct node_t *)malloc(sizeof(struct node_t));
     3498:  474:    q->k = k;
     3498:  475:    q->ak = ak;
     3498:  476:    q->bk = bk;
        -:  477:
     3498:  478:    if (ak > 0 && p->max[k] < INFINITY) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 34% (fallthrough)
branch  3 taken 66%
      590:  479:        q->m = p->m;
     2908:  480:    } else if (ak < 0 && p->min[k] > 0) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
branch  2 taken 18% (fallthrough)
branch  3 taken 82%
      316:  481:        q->m = p->m;
        -:  482:    } else {
     2592:  483:        q->m = p->m + 1;
        -:  484:    }
        -:  485:
     3498:  486:    q->n = p->n;
     3498:  487:    q->h = -1;
     3498:  488:    q->a = (double **)calloc(q->m + 1, sizeof(double*)); // note normally q.m > m
        -:  489:
   109954:  490:    for(int i = 0; i < q->m + 1; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   106456:  491:        q->a[i] = (double *)calloc(q->n + 1, sizeof(double));
        -:  492:    }
        -:  493:
     3498:  494:    q->b = (double *)calloc(q->m + 1, sizeof(double));
     3498:  495:    q->c = (double *)calloc(q->n + 1, sizeof(double));
     3498:  496:    q->x = (double *)calloc(q->n + 1, sizeof(double));
     3498:  497:    q->min = (double *)calloc(n, sizeof(double));
     3498:  498:    q->max = (double *)calloc(n, sizeof(double));
        -:  499:
    73458:  500:    for (int i = 0; i < n; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    69960:  501:        q->min[i] = p->min[i];
    69960:  502:        q->max[i] = p->max[i];
        -:  503:    }
        -:  504:
    73458:  505:    for (int i = 0; i < m; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
  1469160:  506:        for (int j = 0; j < n; j++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
  1399200:  507:            q->a[i][j] = a[i][j];
        -:  508:        }
        -:  509:    }
        -:  510:
    73458:  511:    for (int i = 0; i < m; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    69960:  512:        q->b[i] = b[i];
        -:  513:    }
        -:  514:
    73458:  515:    for (int i = 0; i < n; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    69960:  516:        q->c[i] = c[i];
        -:  517:    }
        -:  518:
     3498:  519:    if (ak > 0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     1749:  520:        if ((isinf(q->max[k]) && q->max[k] > 0) || (bk < q->max[k])) {
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
     1749:  521:            q->max[k] = bk;
        -:  522:        }
     1749:  523:    } else if ((isinf(q->min[k]) && q->min[k] < 0) || (-bk > q->min[k])) {
branch  0 taken 82% (fallthrough)
branch  1 taken 18%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
     1749:  524:        q->min[k] = -bk;
        -:  525:    }
        -:  526:
    73458:  527:    for (int i = m, j = 0; j < n; j++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    69960:  528:        if (!isinf(q->min[j]) || q->min[j] > 0.0) {
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    13195:  529:            q->a[i][j] = -1;
    13195:  530:            q->b[i] = -q->min[j];
    13195:  531:            i++;
        -:  532:        }
    69960:  533:        if (!isinf(q->max[j]) || q->max[j] < 0.0) {
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    19803:  534:            q->a[i][j] = 1;
    19803:  535:            q->b[i] = q->max[j];
    19803:  536:            i++;
        -:  537:        }
        -:  538:    }
        -:  539:
     3498:  540:    return q;
        -:  541:}
        -:  542:
function is_integer called 51804 returned 100% blocks executed 100%
    51804:  543:int is_integer(double* xp){
    51804:  544:    double x = *xp;
    51804:  545:    double r = round(x);
    51804:  546:    if (fabs(r-x) < EPSILON) {
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
    46450:  547:        *xp = r;
    46450:  548:        return 1;
        -:  549:    } else {
     5354:  550:        return 0;
        -:  551:    }
        -:  552:}
        -:  553:
function integer called 2731 returned 100% blocks executed 100%
     2731:  554:int integer(struct node_t* p){
    26412:  555:    for (int i = 0; i < p->n; i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
    26410:  556:        if (!is_integer(&p->x[i])) {
call    0 returned 100%
branch  1 taken 10% (fallthrough)
branch  2 taken 90%
     2729:  557:            return 0;
        -:  558:        }
        -:  559:    }
        2:  560:    return 1;
        -:  561:}
        -:  562:
function bound called 2 returned 100% blocks executed 95%
        2:  563:void bound(struct node_t* p, struct set *h, double* zp, double* x) {
        2:  564:    if (p->z > *zp) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  565:        *zp = p->z;
        -:  566:
       42:  567:        for(int i = 0; i < p->n; i++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       40:  568:            x[i] = p->x[i];
        -:  569:        }
        -:  570:
        2:  571:        if (h->head == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  572:            return;
        -:  573:        }
        -:  574:
        -:  575:        // remove and delete all nodes q in h with q.z < p.z
      851:  576:        while (h->head != NULL && h->head->node->z < p->z) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 99%
branch  3 taken 1% (fallthrough)
      847:  577:            struct set_element *head = h->head;
      847:  578:            h->head = h->head->next;
      847:  579:            free_node(head->node);
call    0 returned 100%
      847:  580:            free(head);
        -:  581:        }
        -:  582:
        2:  583:        struct set_element *element_prev = h->head;
        -:  584:        struct set_element *element;
        -:  585:
        2:  586:        if (h->head == NULL) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  587:            return;
        -:  588:        } else {
        1:  589:            element = h->head->next;
        -:  590:        }
        -:  591:
      459:  592:        while (element != NULL) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
      457:  593:            struct node_t *q = element->node;
      457:  594:            if (q->z < p->z) {
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       29:  595:                element_prev->next = element->next;
       29:  596:                free_node(q);
call    0 returned 100%
       29:  597:                free(element);
       29:  598:                element = element_prev->next;
        -:  599:            } else {
      428:  600:                element_prev = element;
      428:  601:                element = element->next;
        -:  602:            }
        -:  603:        }
        -:  604:    }
        -:  605:}
        -:  606:
function branch called 2729 returned 100% blocks executed 89%
     2729:  607:int branch(struct node_t* q, double z) {
        -:  608:    double min, max;
        -:  609:
     2729:  610:    if (q->z < z) {
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
      104:  611:        return 0;
        -:  612:    }
        -:  613:
    25394:  614:    for (int h = 0; h < q->n; h++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
    25394:  615:        if (!is_integer(&q->x[h])) {
call    0 returned 100%
branch  1 taken 10% (fallthrough)
branch  2 taken 90%
     2625:  616:            if (isinf(q->min[h]) && q->min[h] < 0.0) {
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     2138:  617:                min = 0.0;
        -:  618:            } else {
      487:  619:                min = q->min[h];
        -:  620:            }
     2625:  621:            max = q->max[h];
        -:  622:
     2625:  623:            if (floor(q->x[h]) < min || ceil(q->x[h]) > max) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  624:                continue;
        -:  625:            }
        -:  626:
     2625:  627:            q->h = h;
     2625:  628:            q->xh = q->x[h];
        -:  629:
        -:  630:            /* This causes an error if memory is free
        -:  631:               q is used later in code
        -:  632:            for(int i = 0; i < q->m + 1; i++) {
        -:  633:                free(q->a[i]);
        -:  634:            }
        -:  635:            free(q->a);
        -:  636:            free(q->b);
        -:  637:            free(q->c);
        -:  638:            free(q->x);
        -:  639:            */
        -:  640:
     2625:  641:            return 1;
        -:  642:        }
        -:  643:    }
        -:  644:
    #####:  645:    return 0;
        -:  646:}
        -:  647:
function succ called 3498 returned 100% blocks executed 93%
     3498:  648:void succ(struct node_t *p, struct set *h, int m, int n, double** a, double* b, double* c, int k, double ak, double bk, double* zp, double* x){
     3498:  649:    struct node_t* q = extend(p,m,n,a,b,c,k,ak,bk);
call    0 returned 100%
     3498:  650:    if (q == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  651:        return;
        -:  652:    }
        -:  653:
     3498:  654:    q->z = simplex(q->m, q->n, q->a, q->b, q->c, q->x, 0);
call    0 returned 100%
     3498:  655:    if (isfinite(q->z)) {
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
     2730:  656:        if (integer(q)) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        2:  657:            bound(q,h,zp,x);
call    0 returned 100%
     2728:  658:        } else if (branch(q, *zp)) {
call    0 returned 100%
branch  1 taken 96% (fallthrough)
branch  2 taken 4%
     2624:  659:            push(h, q);
call    0 returned 100%
     2624:  660:            return;
        -:  661:        }
        -:  662:    }
      874:  663:    free_node(q);
call    0 returned 100%
        -:  664:}
        -:  665:
function intopt called 1 returned 100% blocks executed 68%
        1:  666:double intopt(int m, int n, double **a, double *b, double *c, double *x) {
        1:  667:    struct node_t *p = initial_node(m, n, a, b, c);
call    0 returned 100%
        -:  668:    struct set h;
        1:  669:    h.head = create_element(p);
call    0 returned 100%
        1:  670:    double z = -INFINITY;
        1:  671:    p->z = simplex(p->m, p->n, p->a, p->b, p->c, p->x, 0);
call    0 returned 100%
        1:  672:    if(integer(p) || !isfinite(p->z)){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  673:        z = p->z;
    #####:  674:        if (integer(p)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  675:            for(int i = 0; i < n; i++){
branch  0 never executed
branch  1 never executed
    #####:  676:                x[i] = p->x[i];
        -:  677:            }
        -:  678:        }
    #####:  679:        free_node(p);
call    0 never executed
    #####:  680:        free(h.head);
    #####:  681:        return z;
        -:  682:    }
        1:  683:    branch(p,z);
call    0 returned 100%
     1751:  684:    while(h.head != NULL) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
     1749:  685:        struct node_t *p = pop(&h);
call    0 returned 100%
     1749:  686:        succ(p, &h, m, n, a, b, c, p->h, 1, floor(p->xh), &z, x);
call    0 returned 100%
     1749:  687:        succ(p, &h, m, n, a, b, c, p->h, -1, -ceil(p->xh), &z, x);
call    0 returned 100%
     1749:  688:        free_node(p);
call    0 returned 100%
        -:  689:    }
        -:  690:
        1:  691:    if (z == -INFINITY) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  692:        return NAN;
        -:  693:    } else {
        1:  694:        return z;
        -:  695:    }
        -:  696:}
        -:  697:
function free_node called 3499 returned 100% blocks executed 100%
     3499:  698:void free_node(struct node_t* node){
     3499:  699:    free(node->min);
     3499:  700:    free(node->max);
     3499:  701:    free(node->b);
     3499:  702:    free(node->x);
     3499:  703:    free(node->c);
        -:  704:
   109976:  705:    for(int i = 0; i < node->m + 1; i++){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   106477:  706:        free(node->a[i]);
        -:  707:    }
        -:  708:
     3499:  709:    free(node->a);
     3499:  710:    free(node);
     3499:  711:}
